#!/bin/sh
# SPDX-FileCopyrightText: 2020-2023 Klaravdalens Datakonsult AB (KDAB), author David Faure <david.faure@kdab.com>
# SPDX-License-Identifier: MIT

# Generate a CMakeLists.txt based on the .cpp files in the current directory
# Similar to qmake -project, in essence.


usage()
{
  echo "Usage: $0 [ -q | --qt 5 | 6 | 5-and-6 | none ]"
  echo "The -q or --qt option allows to choose between Qt 5, Qt 6, both, or no Qt dependency"
  exit 2
}

PARSED_ARGUMENTS=$(getopt -a -n cmake-project -o q:,h --long qt:,help -- "$@")
INVALID_ARGUMENTS=$?
if [ "$INVALID_ARGUMENTS" != "0" ]; then
  usage
fi

eval set -- "$PARSED_ARGUMENTS"

QTVERSION=5
while :
do
  case "$1" in
    -q | --qt)   QTVERSION="$2"      ; shift 2  ;;
    -h | --help) usage; ;;
    --) shift; break;;
    *) echo "Unexpected option: $1"; usage; ;; # can't happen
  esac
done

#if [ -f CMakeLists.txt ]; then
#    echo "CMakeLists.txt already exists, aborting for safety reasons"
#    exit 1
#fi

SRC="`find -name '*.cpp' -not -path './build/*' | sed -e 's,\.\/,  ,'`"
HEADERS="`find -name '*.h' -not -path './build/*' | sed -e 's,\.\/,  ,'`"
INCLUDES="`find -name '*.h' -type f -not -path './build/*' | sed -E 's|/[^/]+$|/|' | sed -e 's,./,  ,' | uniq`" 
QRCS="`find -name '*.qrc' -not -path './build/*' | sed -e 's,\.\/,  ,'`"
UIS="`find -name '*.ui' -not -path './build/*' | sed -e 's,\.\/,  ,'`"
UI_FOLDERS="`find -name '*.ui' -type f -not -path './build/*' | sed -E 's|/[^/]+$|/|' | sed -e 's,./,  ,' | uniq`"   
if [ -z "$SRC" ]; then
    echo "No cpp files found in the current directory"
    exit 1
fi
PROJECTNAME=`basename "$PWD" | sed -e 's/ /_/g'`
TARGET="$PROJECTNAME"

if [ "$QTVERSION" != "none" ]; then
    if [ "$QTVERSION" = "5-and-6" ]; then
        QT="Qt\${QT_VERSION_MAJOR}"
    else
        QT=Qt$QTVERSION
    fi
    QTLIBS="Core Gui Widgets"
    QTTARGETS="$QT::Core $QT::Gui $QT::Widgets"
    if [ -n "`grep QApplication *.cpp`" ]; then
        QTLIBS="$QTLIBS Widgets"
        QTTARGETS="$QTTARGETS $QT::Widgets"
        AUTOUIC="set(CMAKE_AUTOUIC TRUE)"
    fi
fi

if [ ! -d "cmake" ]; then
  mkdir cmake
fi
SCRIPT=$(dirname -- "$(readlink -f "${BASH_SOURCE}")")
echo "Running script path $SCRIPT"
echo "Destination generation path : $PWD"

cp -r "$SCRIPT/cmake" "$PWD"

cat > CMakeLists.txt <<EOF
cmake_minimum_required(VERSION 3.9)
project($PROJECTNAME)

set(CMAKE_CXX_STANDARD 11)

set(CMAKE_INCLUDE_CURRENT_DIR ON)
EOF

if [ "$QTVERSION" = "5-and-6" ]; then
cat >> CMakeLists.txt <<EOF
find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS $QTLIBS)
EOF
fi

if [ "$QTVERSION" != "none" ]; then
cat >> CMakeLists.txt <<EOF
find_package($QT CONFIG REQUIRED COMPONENTS $QTLIBS)

include(cmake/osdeployqt.cmake)

set(CMAKE_AUTOMOC TRUE)
set(CMAKE_AUTORCC TRUE)
set(CMAKE_AUTOUIC TRUE)
$AUTOUIC	
EOF
fi

cat >> CMakeLists.txt <<EOF
set(SRC
$SRC
)

EOF
cat >> CMakeLists.txt <<EOF
set(HEADERS
$HEADERS
)

EOF
cat >> CMakeLists.txt <<EOF
set(QRCS
$QRCS
)

EOF
cat >> CMakeLists.txt <<EOF
set(UI_FOLDERS
$UI_FOLDERS
)

set(CMAKE_AUTOUIC_SEARCH_PATHS
\${UI_FOLDERS}
)

set(UIS
$UIS
)

EOF

cat >> CMakeLists.txt <<EOF
set(INCLUDE_FOLDERS
	$INCLUDES
)

include_directories(
	\${INCLUDE_FOLDERS}
)

add_executable($PROJECTNAME \${SRC} \${HEADERS} \${QRCS} \${UIS})

EOF

if [ "$QTVERSION" != "none" ]; then
cat >> CMakeLists.txt <<EOF
target_link_libraries($PROJECTNAME $QTTARGETS)

osdeployqt($PROJECTNAME false)
EOF
fi
